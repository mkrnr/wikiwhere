'''
Created on Jan 11, 2016

@author: Martin Koerner <info@mkoerner.de>
'''


from SPARQLWrapper import SPARQLWrapper, JSON
from SPARQLWrapper.SPARQLExceptions import QueryBadFormed

import argparse

# generate help text for arguments
parser = argparse.ArgumentParser(description='Extracts websites with locations from dbpedia.')
parser.add_argument('output',
                   help='a file path to the output file generated by this program')
parser.add_argument("--language", dest="language", metavar='two-letter country code', nargs='?', type=str, help="on of the following language editions of dbpedia (default: en):"
                    + " cs, nl, fr, de, el, it, ja, ko, pl, pt, es")

args = parser.parse_args()


# get mapping from two-letter country code to dbpedia endpoint URL

def language_to_dbpedia_url(argument):
    switcher = {
        # currently available dbpedia language chapters
        # check http://wiki.dbpedia.org/about/language-chapters for updates

        "en": "http://dbpedia.org/sparql",
        "cs": "http://cs.dbpedia.org/sparql",  # Czech    
        "nl": "http://nl.dbpedia.org/sparql",  # Dutch 
        "fr": "http://fr.dbpedia.org/sparql",  # French 
        "de": "http://de.dbpedia.org/sparql",  # German 
        "el": "http://el.dbpedia.org/sparql",  # Greek 
        "it": "http://it.dbpedia.org/sparql",  # Italian
        "ja": "http://ja.dbpedia.org/sparql",  # Japanese 
        "ko": "http://ko.dbpedia.org/sparql",  # Korean 
        "pl": "http://pl.dbepdia.org/sparql",  # Polish 
        "pt": "http://pt.dbpedia.org/sparql",  # Portugese
        "es": "http://es.dbpedia.org/sparql",  # Spanish 
    }
    return switcher.get(argument, "http://dbpedia.org/sparql")

dbpedia_url = language_to_dbpedia_url(args.language) 

print "Running on the following dbpedia SPARQL endpoint: " + dbpedia_url

sparql = SPARQLWrapper(dbpedia_url)
# sparql = SPARQLWrapper("https://query.wikidata.org/sparql")
# sparql = SPARQLWrapper("https://query.wikidata.org/bigdata/namespace/wdq/sparql")

match_out = open(args.output, "wb")  # open output


# SPARQL query that 
namespaces = """
PREFIX dbo: <http://dbpedia.org/resource/classes#>
PREFIX dbp: <http://dbpedia.org/property/>
"""

location_query = """
{
    SELECT * WHERE {
        ?match dbo:locationCity ?locationCity .
        ?locationCity dbp:latitude ?lat .
        ?locationCity dbp:longitude ?long
    }
}
UNION
{
    SELECT * WHERE {
        ?match dbo:locationCity ?locationCity .
        ?locationCity geo:lat ?lat .
        ?locationCity geo:long ?long
    }
}
UNION
{
    SELECT * WHERE {
        ?match dbp:parentAgency ?parentAgency .
        ?parentAgency geo:lat ?lat .
        ?parentAgency geo:long ?long
    }
}
UNION
{
    SELECT * WHERE {
        ?match geo:lat ?lat .
        ?match geo:long ?long
    }
}
UNION
{
    SELECT * WHERE {
        ?match dbo:location ?location .
        ?location geo:lat ?lat .
        ?location geo:long ?long
    }
}
"""
query_string = namespaces + """
SELECT * WHERE {
    {
        SELECT * WHERE {
            ?match foaf:homepage  ?url .
            """ + location_query + """
        }
    }
    UNION
    {
        SELECT * WHERE {
            ?match dbp:url  ?url .
            """ + location_query + """
        }
    }
}
"""

match_count = 0
domain_matches = {}

limit = 5000
offset = 0
while True:
    print offset
    query_string_with_offset = query_string + " LIMIT " + str(limit) + " OFFSET " + str(offset)

    sparql.setQuery(query_string_with_offset)
    sparql.setReturnFormat(JSON)
    try:
        results = sparql.query().convert()
    except QueryBadFormed:
        print "SPARQL query bad formed: " + query_string_with_offset
    
    
    if len(results["results"]["bindings"]) > 0:
        for result in results["results"]["bindings"]:
            match_string = result["url"]["value"] + "\t" + result["match"]["value"] + "\t" + result["lat"]["value"] + "\t" + result["long"]["value"]
            # print match_string
            match_out.write(match_string.encode('utf8') + "\n")
            # print match_string.encode('utf8')
        offset += limit
    else:
        break;

match_out.close()
