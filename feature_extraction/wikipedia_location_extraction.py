'''
Created on Jan 11, 2016

@author: Martin Koerner, Tatiana Sennikova
'''


from SPARQLWrapper import SPARQLWrapper, JSON
from SPARQLWrapper.SPARQLExceptions import QueryBadFormed
import json
import argparse
from utils import dbpedia_mapping
from urllib2 import urlopen


# generate help text for arguments
parser = argparse.ArgumentParser(description='Extracts geo locations from a list of wikipedia articles given in the xml dump format.')
parser.add_argument('input',
                           help='a file path to the output file generated by this program')
parser.add_argument("--output", dest="output", metavar='output path', type=str)
parser.add_argument("--language", dest="language", metavar='two-letter country code', nargs='?', type=str, help="on of the language editions of dbpedia (default: en):")
        
args = parser.parse_args()
        
inputfile_path=args.input
outputfile_path=args.ouput
language = args.language

# Convert coordinates to decimals
def dms2dd(degrees, minutes, seconds, direction):
    dd = float(degrees) + float(minutes)/60 + float(seconds)/(60*60);
    if direction == 'S' or direction == 'W':
        dd *= -1
    return dd;

# Get place using GoogleMaps API
def getplace(lat, lon):
    country=""
    town=""
    url = "http://maps.googleapis.com/maps/api/geocode/json?"
    url += "latlng=%s,%s&sensor=false" % (lat, lon)
    #print url
    v = urlopen(url).read()
    j = json.loads(v)
    #print j
    if j['status']!=u'ZERO_RESULTS':
        components = j['results'][0]['address_components']
        country = town = None
        for c in components:
            if "country" in c['types']:
                country = c['long_name']
            if "postal_town" in c['types']:
                town = c['long_name']
    #print country
    return country


def load_simple_json(filename):
    with open(filename, 'r') as f:
#        return json.load(f)
        return json.load(f)


dump={}        
def query_location(article):
        
    # get mapping from two-letter country code to dbpedia endpoint URL
    print article    
    dbpedia_url = dbpedia_mapping.language_to_dbpedia_url(language) 
    
    article_url = '<http://'+ language + '.wikipedia.org/wiki/'+article + '>'
    location = ""

    sparql = SPARQLWrapper(dbpedia_url)
        
        
    # SPARQL query that 
    namespaces = """
    PREFIX dbo: <http://dbpedia.org/resource/classes#>
    PREFIX dbp: <http://dbpedia.org/property/>
    """
        
    location_query = """        
    {
        SELECT * WHERE {
            ?match dbp:latitude ?lat .
            ?match dbp:longitude ?long
        }
    }
    UNION
    {
        SELECT * WHERE {
            ?match geo:lat ?lat .
            ?match geo:long ?long
        }
    }
    UNION
    {
        SELECT * WHERE {
            ?match dbp:latDeg ?latDeg .
            ?match dbp:latMin ?latMin .
            ?match dbp:latSec ?latSec .
            ?match dbp:lonDeg ?lonDeg .
            ?match dbp:lonMin ?lonMin .
            ?match dbp:lonSec ?lonSec
        }
    }
    UNION
    {
        SELECT * WHERE {
            ?match dbp:latDeg ?latDeg .
            ?match dbp:latMin ?latMin .
            ?match dbp:latSec ?latSec .
            ?match dbp:lonDeg ?lonDeg .
            ?match dbp:lonMin ?lonMin .
            ?match dbp:lonSec ?lonSec .
            ?match dbp:latDir ?latDir .
            ?match dbp:lonDir ?lonDir
        }
    }
    UNION
    {
        SELECT * WHERE {
            ?match dbp:latDegrees ?latDeg .
            ?match dbp:latMinutes ?latMin .
            ?match dbp:latSeconds ?latSec .
            ?match dbp:longDegrees ?lonDeg .
            ?match dbp:longMinutes ?lonMin .
            ?match dbp:longSeconds ?lonSec .
            ?match dbp:latDirection ?latDir .
            ?match dbp:longDirection ?lonDir

        }
    }


    UNION
    {
        SELECT * WHERE {
            ?match dbp:latd ?lat .
            ?match dbp:longd ?long
        }
    }
            
    """
    query_string = namespaces + """
    SELECT * WHERE {
        ?match foaf:isPrimaryTopicOf """+article_url+""" .
        """+location_query+"""
    }
    """
            
    query_string_with_offset = query_string 
        
    sparql.setQuery(query_string_with_offset)
    sparql.setReturnFormat(JSON)
    try:
        results = sparql.query().convert()
    except QueryBadFormed:
        print "SPARQL query bad formed: " + query_string_with_offset
        
        
    if len(results["results"]["bindings"]) > 0:
        for result in results["results"]["bindings"]:
            if  "lat" not in result:
                if "latDir" not in result:
                    latitude=dms2dd(result["latDeg"]["value"], result["latMin"]["value"], result["latSec"]["value"], 0)
                    longetude=dms2dd(result["lonDeg"]["value"], result["lonMin"]["value"], result["lonSec"]["value"], 0)
                    location = getplace(latitude, longetude)
                else:
                    latitude=dms2dd(result["latDeg"]["value"], result["latMin"]["value"], result["latSec"]["value"], result["latDir"]["value"])
                    longetude=dms2dd(result["lonDeg"]["value"], result["lonMin"]["value"], result["lonSec"]["value"], result["lonDir"]["value"])
                    location = getplace(latitude, longetude)

            else:
                location = getplace(result["lat"]["value"], result["long"]["value"])
    return location
    
lang_dump = load_simple_json(inputfile_path)

# Main loop
for article, lang in lang_dump.iteritems():
    article = article.replace(' ', '_')
    location=query_location(article)
    if location!="":
        dump.update({article:location})

with open(outputfile_path, 'w') as f:
    json.dump(dump, f, indent=4, sort_keys=True)
    print "File was stored successfully"